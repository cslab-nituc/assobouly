# アセンブリ言語のモデル
comet2は少し大きいので、もう少し小さいモデルを考える。
## ハードウェアの仕様
- ワード：1語は8ビットである。上位4ビットが命令を表し、下位4ビットがオペランドを表す。
- メモリ：主記憶の容量は16語で、そのアドレスは0〜15番地である。リングバッファを仮定し、15番地の次を0番地とする。
- 数値：0以上の数値を8ビットの2進数で表現する。負数は2の補数で表現する。
- 制御方式：逐次制御で、命令語は1語長である。
- レジスタ：汎用レジスタRegAおよびRegBがあり、8ビットの数値を格納できる。
- プログラムカウンタPC：次に実行すべき命令語のアドレスを保持している。
## 命令（PCの操作が明示されていない場合、終了後に++する）。
 - 
- SaveA N : レジスタAから値を取って「自アドレス＋N」番地に保存する。
- SaveB N : レジスタAから値を取って「自アドレス＋N」番地に保存する。
- LoadA N : 「自アドレス+N」番地のデータをレジスタAにロードする。
- LoadB N : 「自アドレス+N」番地のデータをレジスタBにロードする。
- AddA N : 「自アドレス+N」番地のデータとレジスタAのデータを足し算し、結果をレジスタAにロードする。
- AddB N : 「自アドレス+N」番地のデータとレジスタBのデータを足し算し、結果をレジスタAにロードする。
- Jump N : PC値をN番地増やす
- IfA N :  レジスタAの値が0以外であればPC値をN番地増やす。そうでなければ何もしない。
- IfB N :  レジスタBの値が0以外であればPC値をN番地増やす。そうでなければ何もしない。
- End N :  プログラムを終了する（Nは任意）。

## コードセット
各メモリは8ビットのコードを持つ。
- プログラムとして：「コード名」4ビット＋「N」4ビット
- データとして：8ビットのunsigned

## 実行モデル
- fetch : PCカウンターの示すメモリ上のコードを読み取る。
- decode : 読み取ったコードをプログラムと「N」に分ける。
- execute : プログラムの実行を行い、メモリ、PCカウンタ、レジスタを更新する。

## 数学モデル
有限状態機械によってモデル化される。
### 状態$S$ :  $Mem \times PC \times RegA \times RegB$
ここで、PCはプログラムカウンター値の集合\{0,...,15}, RegAとRegBはレジスター値の集合\{0,...,255\}を表す。
Memはメモリーの状態、すなわち$\{0,...,15\}\rightarrow \{0,...,255\}を表す。
### 遷移$T$ : $S\rightarrow S \cup \{end\}$
$T = \{0,...,255\}$であり、$t\in T$および$s\in S$について、
$t(s) = 
\left\{
    \begin{array}{ll}
    s & tのdecodeに失敗（Save～Endのどの命令でもない）\\
    s' & tがdecodeに成功かつsにおいてその命令を実行後の状態がs'\\
    \end{array}
\right.
$
である場合。特に、命令が「End」の場合、$t(s)= end$と定義する。

### 遷移の詳しい定義
実行前後の状態をそれぞれ
$s=\langle m, pc, ra, rb\rangle$および
$s'=\langle m', pc', ra', rb'\rangle$とする。

- fetch : m(pc)が実行するコードt。
- decode: tの上位4ビットが命令c、下位4ビットがオペランドn。
- execute: cによる場合分け
SaveA: m'(pc + n) = ra。pc' = pc + 1。それ以外は変わらず。
LoadA: ra' = m(pc + n)。pc' = pc + 1。それ以外は変わらず。
ADDA: ra' = ra + m(pc + n)。pc' = pc + 1。それ以外は変わらず。
JMP: pc' = pc + n。それ以外は変わらず。
IFA：ra $\neq$ 0 の場合、pc' = pc + n。そうでない場合、pc' = pc + 1。それ以外は変わらず。
END: 実行後の状態は「end」。

## Cにおける実装
1. コマンド名をenumで定義する。
2. 必要に応じてレジスタ名をenumで定義する。
3. 状態を表す構造体を定義する。
4. 必要に応じて遷移を表す構造体を定義する。
5. fetch関数を定義する。（状態を与え、遷移の番号を返す。）
6. decode関数を定義する。（遷移の番号を与え、遷移、すなわち命令cとオペランドnの組を返す）。
7. execute関数を定義する。（状態と遷移を与え、次の状態を返す）。


